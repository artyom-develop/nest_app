DTO - Data Transfer Object - это паттерн проектирования, используемый для передачи данных между различными слоями приложения или между различными системами. DTO обычно представляет собой простой объект, который содержит только данные без какой-либо бизнес-логики.

Сервисы содержат всю безнес логику приложения  и взаимодействуют с DTO для передачи данных. DTO помогают уменьшить количество вызовов между слоями, так как позволяют передавать сразу несколько полей в одном объекте, а не по отдельности.

Контроллеры принимают запросы от клиентов вызывают соответствующие сервисы, получают DTO и возвращают их клиентам. Таким образом, контроллеры служат посредниками между клиентами и сервисами, обеспечивая правильную маршрутизацию запросов и передачу данных.

Модули организуют код приложения, группируя связанные компоненты, такие как контроллеры, сервисы и DTO, в логические единицы. Это способствует лучшей структуризации кода, облегчает его поддержку и повторное использование.


Сервисы позволяют разгрузить контроллеры и сосердоточить всю бизнес логику в сервисах 

Контроллеры просто принимают запрос и отдают результат работы сервисов


Контроллер получает запрос от клиента и делигирует всю работу сервису

Сервис работает с базой данных обрабатывает ошибки и решает что делать дальше 

DTO валидация данных важно убедиться что мы не просто их плоучили но и получили их в правильном формате например вы ожидаете получить число а получили строку или например получаете email а получили пустую строку, нужно убедиться что email валидный и не пустой и так далее 


Декораторы в nest нужны для декларативного описания поведения классов, методов или параметров и свойств, что делает код лаконичным и выразительным как в angular
Они упаравляют вызовом функций добавляя метаданные через Reflect.metadata, dependency injectoin и middleware бещ boilerplate -кода


Декоратор @Controller('') позволяет маркеровать класс как контроллер, конфигурация для Controller {
    path: путь по которому будет запрашиваться ресурс ,
    host : указаываем что отправлять запросы нужно только с того хоста либо массива хостов  который мы здесь укажем,

}


Что такое параметризированные декораторы, они позволяют нам легко получить параметры запроса, загловки,cookie, и различные параметры из объекта request

@Headers - позволяет получить заголовки запроса
@Param - позволяет получить параметры из пути запроса
@Query - позволяет получить параметры из строки запроса
@Body - позволяет получить тело запроса
@Req - позволяет получить весь объект запроса   
@Res - позволяет получить объект ответа
@Session - позволяет получить сессию пользователя
@Cookies - позволяет получить cookie из запроса
@UploadedFile - позволяет получить загруженный файл из запроса
@UploadedFiles - позволяет получить несколько загруженных файлов из запроса
@Ip - позволяет получить IP адрес клиента

ORM - Это инструмент для работы с базой данных и автоматизации запросов
Вместо того чтобы писать SQL запросы вручную, мы можем использовать ORM для взаимодействия с базой данных через объекты и методы, что упрощает разработку и повышает производительность.

ORM позволяет нам управлять миграциями 
Миграции это специальные скрипты которые позволяют изменять структуру базы данных без потери данных
Простота и удобство использования ORM
ORM предоставляет удобный и интуитивно понятный интерфейс для работы с базой данных


Связи 
one-to-one - один к одному  
one-to-many - один ко многим
many-to-many - многие ко многим

чтобы инициализировать призму в проекте устанавливаем prisma @prisma/client и выполняем команду (bun | npm | yarn )prisma init 


Prisma - это современный ORM (Object-Relational Mapping) инструмент для работы с базами данных в приложениях на JavaScript и TypeScript. Prisma упрощает взаимодействие с базой данных, предоставляя удобный и типизированный интерфейс для выполнения запросов и управления данными.

в prisma.config.ts мы указываем тип базы данных и путь к файлу схемы базы данных

В файле schema.prisma мы определяем модели данных, которые соответствуют таблицам в базе данных, а также их поля и типы данных.'

Чтобы описать связи между моделями в Prisma, мы используем специальные атрибуты и поля в определении моделей. Вот как можно описать основные типы связей:
- One-to-One (Один к одному):
  В модели добавляем поле, которое ссылается на другую модель, и используем атрибут @relation для указания связи.
- One-to-Many (Один ко многим):
  В "одной" модели добавляем массив, который ссылается на "многие" модель, а в "многой" модели добавляем поле, которое ссылается на "одну" модель.
- Many-to-Many (Многие ко многим):
  Создаем промежуточную модель, которая содержит ссылки на обе связанные модели, и используем массивы в обеих моделях для указания связи.   


middleware - это функции, которые выполняются в процессе обработки запроса до того, как он достигнет конечной точки (например, контроллера) и после того, как ответ был сформирован. Middleware позволяет добавлять дополнительную логику, такую как аутентификация, логирование, обработка ошибок и другие операции, которые должны выполняться для каждого запроса.


 configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggingMiddleware).forRoutes({path: '/movies', method: RequestMethod.POST})
  }

Это пример подключения в app модуле middleware LoggingMiddleware, который будет применяться только к POST запросам на путь /movies. Если хотим чтобы к каждому запросу применялся то пишет просто forRoutes('*')
Если хотим чтобы применялся только к определнному контроллеру то пишем forRoutes(ControllerClassName)

Pipe - это классы или функции, которые используются для трансформации и валидации данных в NestJS. Они позволяют обрабатывать входящие данные перед тем, как они будут переданы в контроллеры или сервисы.
подключить можно на уровне глобально в main.ts или на уровне контроллера или отдельного маршрута с помощью декоратора @UsePipes()

guard - это классы или функции, которые используются для контроля доступа к определенным маршрутам или ресурсам в приложениях на NestJS. Они позволяют определять, имеет ли пользователь необходимые права или условия для выполнения определенного действия. Guards выполняются до того, как запрос достигает контроллера, и могут блокировать или разрешать доступ на основе заданных правил.

Guard можно применять как глобально в main.ts так и на уровне контроллера или отдельного маршрута с помощью декоратора @UseGuards()


Кастомные декораторы они позволяют добавлять дополнительные метаданнные или логику к классам, методам или параметрам в NestJS. Они создаются с помощью функции createParamDecorator из пакета @nestjs/common и могут использоваться для упрощения доступа к определенным данным или функциональности в контроллерах и сервисах.


Интерсепторы - это классы или функции, которые позволяют перехватывать и изменять входящие запросы и исходящие ответы в приложениях на NestJS. Они выполняются до и после обработки запроса контроллером, что позволяет добавлять дополнительную логику, такую как логирование, кэширование, трансформация данных и обработка ошибок.


Filters - это классы или функции, которые используются для обработки и управления ошибками в приложениях на NestJS. Они позволяют перехватывать исключения, возникающие во время выполнения запросов, и формировать соответствующие ответы для клиентов. Фильтры ошибок помогают централизованно обрабатывать ошибки, улучшая читаемость и поддержку кода.