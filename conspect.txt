DTO - Data Transfer Object - это паттерн проектирования, используемый для передачи данных между различными слоями приложения или между различными системами. DTO обычно представляет собой простой объект, который содержит только данные без какой-либо бизнес-логики.

Сервисы содержат всю безнес логику приложения  и взаимодействуют с DTO для передачи данных. DTO помогают уменьшить количество вызовов между слоями, так как позволяют передавать сразу несколько полей в одном объекте, а не по отдельности.

Контроллеры принимают запросы от клиентов вызывают соответствующие сервисы, получают DTO и возвращают их клиентам. Таким образом, контроллеры служат посредниками между клиентами и сервисами, обеспечивая правильную маршрутизацию запросов и передачу данных.

Модули организуют код приложения, группируя связанные компоненты, такие как контроллеры, сервисы и DTO, в логические единицы. Это способствует лучшей структуризации кода, облегчает его поддержку и повторное использование.


Сервисы позволяют разгрузить контроллеры и сосердоточить всю бизнес логику в сервисах 

Контроллеры просто принимают запрос и отдают результат работы сервисов


Контроллер получает запрос от клиента и делигирует всю работу сервису

Сервис работает с базой данных обрабатывает ошибки и решает что делать дальше 

DTO валидация данных важно убедиться что мы не просто их плоучили но и получили их в правильном формате например вы ожидаете получить число а получили строку или например получаете email а получили пустую строку, нужно убедиться что email валидный и не пустой и так далее 


Декораторы в nest нужны для декларативного описания поведения классов, методов или параметров и свойств, что делает код лаконичным и выразительным как в angular
Они упаравляют вызовом функций добавляя метаданные через Reflect.metadata, dependency injectoin и middleware бещ boilerplate -кода


Декоратор @Controller('') позволяет маркеровать класс как контроллер, конфигурация для Controller {
    path: путь по которому будет запрашиваться ресурс ,
    host : указаываем что отправлять запросы нужно только с того хоста либо массива хостов  который мы здесь укажем,

}


Что такое параметризированные декораторы, они позволяют нам легко получить параметры запроса, загловки,cookie, и различные параметры из объекта request

@Headers - позволяет получить заголовки запроса
@Param - позволяет получить параметры из пути запроса
@Query - позволяет получить параметры из строки запроса
@Body - позволяет получить тело запроса
@Req - позволяет получить весь объект запроса   
@Res - позволяет получить объект ответа
@Session - позволяет получить сессию пользователя
@Cookies - позволяет получить cookie из запроса
@UploadedFile - позволяет получить загруженный файл из запроса
@UploadedFiles - позволяет получить несколько загруженных файлов из запроса
@Ip - позволяет получить IP адрес клиента

ORM - Это инструмент для работы с базой данных и автоматизации запросов
Вместо того чтобы писать SQL запросы вручную, мы можем использовать ORM для взаимодействия с базой данных через объекты и методы, что упрощает разработку и повышает производительность.

ORM позволяет нам управлять миграциями 
Миграции это специальные скрипты которые позволяют изменять структуру базы данных без потери данных
Простота и удобство использования ORM
ORM предоставляет удобный и интуитивно понятный интерфейс для работы с базой данных


Связи 
one-to-one - один к одному  
one-to-many - один ко многим
many-to-many - многие ко многим

чтобы инициализировать призму в проекте устанавливаем prisma @prisma/client и выполняем команду (bun | npm | yarn )prisma init 


Prisma - это современный ORM (Object-Relational Mapping) инструмент для работы с базами данных в приложениях на JavaScript и TypeScript. Prisma упрощает взаимодействие с базой данных, предоставляя удобный и типизированный интерфейс для выполнения запросов и управления данными.

в prisma.config.ts мы указываем тип базы данных и путь к файлу схемы базы данных

В файле schema.prisma мы определяем модели данных, которые соответствуют таблицам в базе данных, а также их поля и типы данных.'

Чтобы описать связи между моделями в Prisma, мы используем специальные атрибуты и поля в определении моделей. Вот как можно описать основные типы связей:
- One-to-One (Один к одному):
  В модели добавляем поле, которое ссылается на другую модель, и используем атрибут @relation для указания связи.
- One-to-Many (Один ко многим):
  В "одной" модели добавляем массив, который ссылается на "многие" модель, а в "многой" модели добавляем поле, которое ссылается на "одну" модель.
- Many-to-Many (Многие ко многим):
  Создаем промежуточную модель, которая содержит ссылки на обе связанные модели, и используем массивы в обеих моделях для указания связи.   


middleware - это функции, которые выполняются в процессе обработки запроса до того, как он достигнет конечной точки (например, контроллера) и после того, как ответ был сформирован. Middleware позволяет добавлять дополнительную логику, такую как аутентификация, логирование, обработка ошибок и другие операции, которые должны выполняться для каждого запроса.


 configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggingMiddleware).forRoutes({path: '/movies', method: RequestMethod.POST})
  }

Это пример подключения в app модуле middleware LoggingMiddleware, который будет применяться только к POST запросам на путь /movies. Если хотим чтобы к каждому запросу применялся то пишет просто forRoutes('*')
Если хотим чтобы применялся только к определнному контроллеру то пишем forRoutes(ControllerClassName)

Pipe - это классы или функции, которые используются для трансформации и валидации данных в NestJS. Они позволяют обрабатывать входящие данные перед тем, как они будут переданы в контроллеры или сервисы.
подключить можно на уровне глобально в main.ts или на уровне контроллера или отдельного маршрута с помощью декоратора @UsePipes()

guard - это классы или функции, которые используются для контроля доступа к определенным маршрутам или ресурсам в приложениях на NestJS. Они позволяют определять, имеет ли пользователь необходимые права или условия для выполнения определенного действия. Guards выполняются до того, как запрос достигает контроллера, и могут блокировать или разрешать доступ на основе заданных правил.

Guard можно применять как глобально в main.ts так и на уровне контроллера или отдельного маршрута с помощью декоратора @UseGuards()


Кастомные декораторы они позволяют добавлять дополнительные метаданнные или логику к классам, методам или параметрам в NestJS. Они создаются с помощью функции createParamDecorator из пакета @nestjs/common и могут использоваться для упрощения доступа к определенным данным или функциональности в контроллерах и сервисах.


Интерсепторы - это классы или функции, которые позволяют перехватывать и изменять входящие запросы и исходящие ответы в приложениях на NestJS. Они выполняются до и после обработки запроса контроллером, что позволяет добавлять дополнительную логику, такую как логирование, кэширование, трансформация данных и обработка ошибок.


Filters - это классы или функции, которые используются для обработки и управления ошибками в приложениях на NestJS. Они позволяют перехватывать исключения, возникающие во время выполнения запросов, и формировать соответствующие ответы для клиентов. Фильтры ошибок помогают централизованно обрабатывать ошибки, улучшая читаемость и поддержку кода.

Open Api - это спецификация для описания и документирования RESTful API. Она позволяет разработчикам создавать, визуализировать и тестировать API, обеспечивая стандартизированный формат для описания его структуры, эндпоинтов, параметров и ответов. OpenAPI способствует улучшению взаимодействия между командами разработки и упрощает интеграцию с внешними сервисами.
Например использование Swagger в NestJS позволяет автоматически генерировать документацию для API на основе аннотаций в коде, что облегчает понимание и использование API другими разработчиками.



409 - Conflict - Конфликт - Этот статус указывает на то, что запрос не может быть выполнен из-за конфликта с текущим состоянием ресурса. Например, попытка создать ресурс с уже существующим уникальным идентификатором.

201 статус - Created - Создано - Этот статус указывает на успешное создание нового ресурса в ответ на запрос клиента. Обычно используется в ответ на POST-запросы, когда новый объект был успешно создан на сервере.

200 - статус - OK - Успешно - Этот статус указывает на успешное выполнение запроса клиента. Он означает, что запрос был обработан успешно, и сервер возвращает запрашиваемые данные или подтверждение выполнения операции.

Декоратор HttpCode() позволяет явно указать HTTP статус код, который должен быть возвращен в ответе на запрос. По умолчанию NestJS использует стандартные коды статусов в зависимости от типа запроса (например, 200 для успешных GET запросов, 201 для успешных POST запросов и т.д.). Однако, с помощью декоратора HttpCode, разработчик может переопределить этот поведение и задать конкретный статус код для определенного метода контроллера.

Библиотека Argon2 - это современный и безопасный алгоритм хеширования паролей, который был разработан для обеспечения высокой безопасности и устойчивости к атакам. Argon2 был признан лучшим алгоритмом хеширования паролей на конкурсе Password Hashing Competition в 2015 году.

JWT (JSON WEB TOKEN) - это стандарт для создания токенов доступа, которые позволяют безопасно передавать информацию между сторонами в виде JSON объектов. JWT часто используется для аутентификации и авторизации пользователей в веб-приложениях.


Из чего состоит JWT токен - JWT токен состоит из трех частей, разделенных точками (.):
1. Header (Заголовок): Содержит информацию о типе токена (обычно "JWT") и алгоритме подписи (например, HMAC SHA256 или RSA).
2. Payload (Полезная нагрузка): Содержит утверждения (claims) о пользователе и дополнительные данные. Утверждения могут быть стандартными (например, iss - издатель, exp - время истечения) или пользовательскими.
3. Signature (Подпись): Создается путем кодирования заголовка и полезной нагрузки с использованием секретного ключа и указанного алгоритма подписи. Подпись обеспечивает целостность токена и подтверждает его подлинность.

Алгоритм HS256 (HMAC SHA256) - это криптографический алгоритм, который используется для создания цифровых подписей и проверки целостности данных. HS256 является одним из алгоритмов, используемых в JWT (JSON Web Token) для подписи токенов.
Преимущества использования HS256:
1. Безопасность: HS256 использует секретный ключ для создания подписи, что обеспечивает защиту от подделки токенов.
2. Быстрота: HS256 является относительно быстрым алгоритмом, что делает его подходящим для использования в веб-приложениях с высокой нагрузкой. 
3. Простота: HS256 легко реализуется и интегрируется в различные приложения и системы.
4. Совместимость: HS256 поддерживается большинством библиотек и фреймворков, работающих с JWT, что облегчает его использование в различных средах разработки.
5. Широкое применение: HS256 широко используется в индустрии для аутентификации и авторизации пользователей, что делает его проверенным и надежным выбором для многих приложений.

Как использовать JWT в NestJS -
1. Установка библиотеки: Установите необходимые пакеты, такие как @nestjs/jwt и jsonwebtoken.
2. Конфигурация модуля JWT: Создайте модуль JWT в вашем приложении NestJS и настройте его с использованием секретного ключа и параметров токена (например, время истечения).
3. Создание сервиса аутентификации: Создайте сервис, который будет отвечать за генерацию и валидацию JWT токенов.
4. Генерация токенов: В сервисе аутентификации реализуйте метод для создания JWT токенов при успешной аутентификации пользователя.
5. Защита маршрутов: Используйте Guards для защиты маршрутов, требующих аутентификации, проверяя наличие и валидность JWT токена в заголовках запросов.
6. Обработка ошибок: Реализуйте обработку ошибок для случаев, когда токен недействителен или истек.

Библиотека Argon2 используется для безопасного хеширования паролей в приложениях. Она обеспечивает защиту паролей от атак, таких как перебор и атаки с использованием радужных таблиц, благодаря использованию адаптивного алгоритма хеширования, который можно настроить для увеличения сложности с течением времени.

Библиотека cookie-parser - это middleware для Node.js, которое используется для парсинга (разбора) cookie-файлов, отправленных клиентом в HTTP-запросах. Она позволяет легко получать доступ к значениям cookie в вашем приложении, что упрощает управление сессиями, аутентификацией и другими функциями, связанными с cookie.


Redis - это высокопроизводительная система управления базами данных в памяти, которая используется для кэширования данных и улучшения производительности приложений. Redis поддерживает различные структуры данных, такие как строки, хэши, списки, множества и упорядоченные множества, что делает его гибким инструментом для хранения и обработки данных.

JWT стратегия - это набор правил и методов, используемых для аутентификации и авторизации пользователей с помощью JSON Web Tokens (JWT) в приложениях. Она определяет, как токены создаются, проверяются и используются для предоставления доступа к защищенным ресурсам.